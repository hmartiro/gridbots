"""

"""

import os
import sys
import logging
import datetime
import mathutils as mu

import gridbots
from gridbots.core.routine import TrajectoryBuilder

LATTICE_SPACING = 12  # mm


class LatticeController():

    def _header(self):

        self.commands.extend((
            '# -------------------------------------------------------',
            '# Autogenerated build script for ',
            '#     {}'.format(self.structure.structure_file),
            '#',
            '# Date: {}'.format(str(datetime.datetime.now())),
            '# -------------------------------------------------------',
            ''
        ))

    def _start_to_tree(self):

        self.commands.extend((
            '# TRANSITION: start -> tree',
            '# -----------------------------',
            '<units1&2_buffer_reverse',
            '<units1&2_tree_ready',
            '<units1&2_buffer_reverse',
            '',
            'stagerel(12, 0, 0)',
            'stagerel(-6, 0, 0)',
            '# -----------------------------',
            ''
        ))

    def _tree(self, v1, v2):

        v1_mm = mu.Vector(v1) * LATTICE_SPACING
        move = self.stage_pos - v1_mm
        self.stage_pos -= move

        self.commands.extend((
            '# Place tree rod from {} to {}'.format(v1, v2),
            'stagerel({},{},{})'.format(move.x, move.y, move.z),
            '<unit2_tree_int_AH.txt'
            ''
        ))

    def _tree_to_vert(self):

        self.commands.extend((
            'stagerel(+6, 0, 0)',
            '',
            '# TRANSITION: tree -> vert',
            '# -----------------------------',
            'stagerel(0, 0, -12)',
            '<units1&2_buffer_advance',
            '<units1&2_buffer_advance',
            '',
            '# Fix the glue gap',
            'stagerel(1, -1, 0)',
            '',
            'stagerel(8,0,0)',
            '# -----------------------------',
            ''
        ))

    def _vert(self, v1, v2):

        v1_mm = mu.Vector(v1) * LATTICE_SPACING
        move = self.stage_pos - v1_mm
        self.stage_pos -= move

        self.commands.extend((
            '# Place vertical rod from {} to {}'.format(v1, v2),
            'stagerel({},{},{})'.format(move.x, move.y, move.z),
            '<unit2_vert_int',
            'stagerel(0,-12,0)',
            ''
        ))

    def _vert_to_horz(self):
        self.commands.extend((
            '# Undo fix the glue gap',
            'stagerel(-1, 1, 0)',
            '',
            '# TRANSITION: vert -> horz',
            '# -----------------------------',
            'stagerel(0, -12, 12)',
            '<units1&2_buffer_reverse',
            '<units1&2_horz_ready',
            '<units1&2_buffer_reverse',
            '<units1&2_buffer_reverse',
            '',
            '# This is for rod alignment asymmetry ?',
            'stagerel(0, -2, 0)',
            '',
            '# -----------------------------',
            ''
        ))

    def _horz(self, v1, v2):

        v1_mm = mu.Vector(v1) * LATTICE_SPACING
        move = self.stage_pos - v1_mm
        self.stage_pos -= move

        self.commands.extend((
            '# Place horizontal rod from {} to {}'.format(v1, v2),
            'stagerel({},{},{})'.format(move.x, move.y, move.z),
            '<unit2_horz_int',
            'stagerel(0,-12,0)',
            ''
        ))

    def _horz_to_tlap(self):
        self.commands.extend((
            '# Undo rod alignment asymmetry ?',
            'stagerel(0, +2, 0)',
            '',
            '# TRANSITION: horz -> tlap',
            '# -----------------------------',
            '<units1&2_buffer_advance',
            '<units1&2_buffer_advance',
            '<units1&2_tree_ready',
            '<units1&2_buffer_advance',
            'stagerel(-12,12,0)',
            '',
            '# -----------------------------',
            ''
        ))

    def _tlap(self, v1, v2):

        v1_mm = mu.Vector(v1) * LATTICE_SPACING
        move = self.stage_pos - v1_mm
        self.stage_pos -= move

        self.commands.extend((
            '# Place tree rod from {} to {}'.format(v1, v2),
            'stagerel({},{},{})'.format(move.x, move.y, move.z),
            '<unit2_tlap_int',
            'stagerel(0,-12,0)',
            ''
        ))

    def _tlap_to_vert(self):

        self.commands.extend((
            '# TRANSITION: tlap -> vert',
            '# -----------------------------',
            'stagerel(12,0,-12)',
            '',
            '# align, getsolv, getwater_soak left out here',
            '',
            '# Fix the glue gap',
            'stagerel(1, -1, 0)',
            '# -----------------------------',
            ''
        ))

    def _footer(self):

        self.commands.extend((
            '# -------------------------------------------------------',
            '# End autogenerated build script',
            '# -------------------------------------------------------',
            ''
        ))

    def __init__(self, bots, sim, structure):

        self.logger = logging.getLogger(__name__)
        self.bots = bots
        self.sim = sim
        self.structure = structure
        self.finished = False

        self.rod_queue = structure.edges

        self.stage_pos = mu.Vector([0, 0, 0])

        self.commands = []

        self._header()

        modes = {
            'uninit',  # uninit
            'tree',  # putting down first layer of trees
            'tlap',  # putting down trees
            'vert',  # putting down verticals
            'horz'   # putting down horizontals
        }
        mode = 'tree'

        self._start_to_tree()

        # Create a set of tree attachment points by looking at the verticals
        # of the first layer
        tree_verts = set()
        for e in self.rod_queue:
            v1 = tuple(self.structure.vertices[e[0]])
            v2 = tuple(self.structure.vertices[e[1]])

            if not self.is_z_rod(v1, v2):
                break

            tree_verts.add(v1)
            tree_verts.add(v2)

        # Sort into build order
        tree_verts = list(tree_verts)
        tree_verts.sort(key=lambda p: (-p[0], -p[2], -p[1]))

        # Build the trees
        for v in tree_verts:
            self._tree(v, [v[0]+1, v[1], v[2]])

        for e in self.rod_queue:

            v1 = self.structure.vertices[e[0]]
            v2 = self.structure.vertices[e[1]]
            rod = (v1, v2)

            # Tree rod is next
            if self.is_x_rod(v1, v2):

                if mode == 'horz':
                    self._horz_to_tlap()
                    self._tlap(v1, v2)

                elif mode == 'tlap':
                    self._tlap(v1, v2)

                else:
                    raise Exception('Cannot enter tlap mode from {}!'.format(mode))

                self.logger.info('tree rod: {}'.format(rod))
                mode = 'tlap'

            # Horizontal rod is next
            elif self.is_y_rod(v1, v2):

                if mode == 'vert':
                    self._vert_to_horz()
                    self._horz(v1, v2)

                elif mode == 'horz':
                    self._horz(v1, v2)

                else:
                    raise Exception('Cannot enter horz mode from {}!'.format(mode))

                self.logger.info('horizontal rod: {}'.format(rod))
                mode = 'horz'

            # Vertical rod is next
            elif self.is_z_rod(v1, v2):

                if mode == 'tree':
                    self._tree_to_vert()
                    self._vert(v1, v2)

                elif mode == 'tlap':
                    self._tlap_to_vert()
                    self._vert(v1, v2)

                elif mode == 'vert':
                    self._vert(v1, v2)

                else:
                    raise Exception('Cannot enter vert mode from {}!'.format(mode))

                self.logger.info('vertical rod: {}'.format(rod))
                mode = 'vert'

            else:
                raise Exception('Cannot tell type of active rod: {}'.format(rod))

        self._footer()

        script_str = '\n'.join(self.commands)
        print(script_str)

        script_dir = os.path.join(gridbots.path, 'sri-scripts')
        script_name = '_{}.txt'.format(self.sim.sim_name)
        script_path = os.path.join(script_dir, script_name)

        with open(script_path, 'w') as f:
            f.write(script_str)

        builder = TrajectoryBuilder(script_dir, script_name)
        self.routine = builder.moves

    @staticmethod
    def is_x_rod(v1, v2):
        return (v1[1] - v2[1] == 0) and (v1[2] - v2[2] == 0)

    @staticmethod
    def is_z_rod(v1, v2):
        return (v1[0] - v2[0] == 0) and (v1[1] - v2[1] == 0)

    @staticmethod
    def is_y_rod(v1, v2):
        return (v1[0] - v2[0] == 0) and (v1[2] - v2[2] == 0)

    def step(self, frame):

        if frame >= len(self.routine):
            self.finished = True
            return {}

        return self.routine[frame]
